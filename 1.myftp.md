# myFTP 协议

> 请从[北大教学网](https://course.pku.edu.cn)获取接受本Lab任务的链接

MyFTP是我们为了方便同学们快速理解POSIX API设计的一个简单的Lab

在这个Lab中你需要完成一个简单的基于Epoll的单线程FTP Server和FTP Client CLI

Server

本文档描述了MyFTP协议的内容

## 实现要求

1. MyFTP的Client支持以下的命令
    1. `open <IP> <port>`: 建立一个到`<IP>:<port>`的连接
    2. `auth <username> <password>`: 向对侧进行身份验证
    3. `ls`: 获取对方当前运行目录下的文件列表，一个样例输出如下:
        ``` cpp
        123.txt
        ```
    4. `get <filename>`: 将Server运行目录中的`<filename>`文件存放到Client运行目录的`<filename>`中
    5. `put <filename>`: 将Client运行目录中的`<filename>`文件存放当Server运行目录的`<filename>`中
    6. `quit`: 如有连接则先断开，后关闭Client
2. MyFTP的Server需要支持如下的功能特点
    1. 权限控制: 用户需要登录这里简化为用户名为`user`密码为`123123`
    2. 获取文件列表: 这里文件列表由指令`ls -r`生成，可以使用`popen`或者`pipe+fork+execv`的手段获取其他进程的输出结果
    3. 下载文件
    4. 上传文件

### Client实现要求

我们在测试的过程中会通过指令`./ftp_server`在`build`目录中启动Client

### Server实现要求

我们会用指令`./ftp_client <IP> <Port>`在`build`目录中启动Server

## 技术规范

### 数据报文格式

``` cpp
struct {
    byte m_protocol[MAGIC_NUMBER_LENGTH]; /* protocol magic number (6 bytes) */
    type m_type;                          /* type (1 byte) */
    status m_status;                      /* status (1 byte) */
    uint32_t m_length;                    /* length (4 bytes) in Big endian*/
} __attribute__ ((packed));
```

每一个数据报文的开头都将以这个报头发送，基于TCP协议进行通信

即每一个802.3网络上的报文都有如下的形式:

`|802.3 Header|IP Header|TCP Header|myFTP Header|myFTP Data|data|`

其中TCP Header以及之前的头会由系统生成, 我们要实现的是一个应用层协议

### 网络请求

对于所有的请求，头中的`m_protocol`字段的值都应当为

``` cpp
const byte MAGIC_NUMBER[MAGIC_NUMBER_LENGTH] = {'\xe3', 'm', 'y', 'f', 't', 'p'};
```

每一种类型的请求和对应的回复的`m_type`为:

``` cpp
const type OPEN_CONN_REQUEST = '\xA1';
const type OPEN_CONN_REPLY = '\xA2';
const type AUTH_REQUEST = '\xA3';
const type AUTH_REPLY = '\xA4';
const type LIST_REQUEST = '\xA5';
const type LIST_REPLY = '\xA6';
const type GET_REQUEST = '\xA7';
const type GET_REPLY = '\xA8';
const type FILE_DATA = '\xFF';
const type PUT_REQUEST = '\xA9';
const type PUT_REPLY = '\xAA';
const type QUIT_REQUEST = '\xAB';
const type QUIT_REPLY = '\xAC';
```

对于请求的`m_status`字段没有特殊作用，对于回复可能存在如下的值:

``` cpp
const status UNUSED = 0;
const status UP = 1;
const status DOWN = 0;
const status SUCCESS = 1;
const status FAIL = 0;
```

具体发生情况会在下面给出, 该选项只会为0或者1, 从更全面的角度来看1表示请求成功, 0表示请求失败

报文的长度`m_length`为**大端法**表示，长度包括包头和数据的**总长度**, 你可以认为在任何时候报文的长度不会超过`limits.h`中定义的`INT_MAX`

### 协议概述

![](1.png)

上图描述了Client的状态机, Server对于每一个Client, 以及Client自身都应当维护这样一个简单的状态机

Client在每一个时刻只能执行一个请求, 只有当前一个请求收到对应的回复后才能执行下一个请求

### Open a Connection

Client和Server会按照如下的步骤进行交互:

1. 当用户在Client中输入`open SERVER_IP SERVER_PORT`时, 尝试建立一个到`SERVER_IP:SERVER_PORT`的TCP连接
2. 建立后Client向Server发起请求`m_type=OPEN_CONN_REQUEST`
3. 若Server正在执行,则发起回复`m_type=OPEN_CONN_REPLY, m_status=UP(1)`

![](2.png)

### Authentication

1. 当`Open a Connection`一节成功执行后, Client需要向Server进行身份验证. 当用户在Client中输入`auth USER PASS`时, Client向Server发起请求`m_type=AUTH_REQUEST`其内容为`"USER PASS\0"`
2. 为了简化Server的实现, Server只有一个用户`USER=user, PASS=123123`,以该用户为例,请求报文的data应当为`"user 123123\0"`, 若身份验证通过, 则返回报文`m_type=AUTH_REPLY, m_status=1`. 否则返回报文`m_type=AUTH_REPLY, m_status=0`

### List Files

当完成验证后, 用户可以通过Client执行List Files的指令, 具体执行流程如下:

1. 当用户在Client中输入`ls`指令后Client将发送请求`m_type=LIST_REQUEST`请求
2. 当Server收到请求后, 若该Client有权限, 则返回`m_type=LIST_REPLY, m_status=UNUSED`, 其data为在Server的**运行目录**(指执行server命令时的目录,而不是可执行文件ftpserver所在的目录)中执行`ls`指令后的结果(注意在返回时应当在末尾补入一个`'\0'`)

> 这里你可以通过`popen`或者`fork,pipe,exec`等方式实现获取`ls`指令的结果

* 这里保证`ls`的返回结果长度不会超过2047bytes

![](3.png)

### Download Files

当用户希望从Server获取数据时执行流程如下:

1. 用户在Client中输入`get FILE`指令, Client向Server发送请求`m_type=GET_REQUEST`, 该请求的data为`FILE\0`, 举例而言若为`123.txt`则发送的data为`"123.txt\0"`
2. Server收到请求后检查该文件是否存在, 若存在则返回请求`m_type=GET_REPLY, m_status=1`否则`m_type=GET_REPLY, m_status=0`
3. 若成功则Server再发送一个报文`m_type=FILE_DATA, m_status=UNUSED`其中data为对应的文件内容, 这里保证文件大小不会超过1MB

![](4.png)

### Upload Files

当用户希望上传一个**文件**到Server时执行流程如下:

1. 用户在Client中输入`put FILE`指令, Client向Server发送请求`m_type=PUT_REQUEST`, 该请求的data为`FILE\0`, 举例而言若为`123.txt`则发送的data为`"123.txt\0"`
2. Server收到请求后若可以创建该文件则返回`m_type=PUT_REPLY, m_status=1`
3. 在收到回复后Client发送一个`m_type=FILE_DATA`的请求, 该请求的data为文件的二进制数据

![](5.png)

### Close Connection

该指令由Client发出，用户在向Client输入`quit`指令后

若Client已经成功之行Open a connection, 则向Server发送`m_type=QUIT_REQUEST`请求

此时Server应当回复`m_type = QUIT_REPLY, m_status = UNUSED`

当收到Server的回复**后**，Client才应当关闭该连接

## 如何进行本地测试

### 编译准备

我们采用了gtest进行测试，CMake会自动从Github克隆仓库，因此请保证至少你的Terminal能够访问Github

如果无法进行正常测试，请和助教联系

1. 从远程仓库clone
2. 在根目录中执行`git submodule update --init`
3. 在根目录中执行`git submodule update --remote`
4. 在根目录中执行`mkdir build && cd build && cmake ..`


**编译测试程序** 在根目录中执行`cd test_local && mkdir build && cd build && cmake .. && make`, 这会编译自动测试程序, 注意若自动测试程序发生更新则需要执行如下指令获取最新的测试程序:

1. 在根目录中执行`git submodule update --remote`
2. 在根目录中执行`cd test_local && mkdir build && cd build && cmake .. && make`

> 将文件`test_local/ftp_client_std, test_local/ftp_server_std, test_local/build/ftp_test`拷贝到`build/`中即可, 该操作只有第一次或测试程序更新后需要执行

### 编译

在根目录的`build`目录中执行`make`即可编译

### 执行

在build目录中执行`.\ftp_test`即可进行测试

要求:
1. Server可执行程序和Client可执行程序名称需要严格按照`ftp_server`和`ftp_client`命名 (在下发的模板中我们已经完成了这一段代码)你只需要将对应的源文件添加到CMake中对应的target上即可
2. 具体协议内容请参考技术规范一节实现,在进行某一项测试的时候,只有一侧会使用你的Server/Client,另一侧为标准程序,为了确保能够正常通信,我们希望你的代码能够和标准程序进行交互
3. 任何对提供的**二进制文件**的修改均被视为作弊行为, 一经发现该Lab将被记为0分

## 分数计算

注意这里测试点不代表所有测试点, 这里展示的测试点只占最终该Lab分数的80%, 剩余的测试点会在Deadline后放出

以下的表格给出了每一个测试点对应的ID和内容，你可以通过`.\ftp_test --gtest_filter=ID`来只针对某个测试点执行测试

或者使用通配符如`.\ftp_test --gtest_filter=FTPServer.*`只针对Server进行测试

每一个测试点名由`${类别}.${测试点名称}`构成

<table>
    <tr>
        <td>类别</td>
        <td>测试点名称</td>
        <td>测试内容</td>
        <td>分数占比</td>
    </tr>
    <tr>
        <td rowspan="5">FTPServer</td>
        <td>Open</td>
        <td>测试OPEN_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Auth</td>
        <td>测试AUTH_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Get</td>
        <td>测试GET_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Put</td>
        <td>测试PUT_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>List</td>
        <td>测试LIST_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td rowspan="4">FTPClient</td>
        <td>Open</td>
        <td>测试OPEN_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Auth</td>
        <td>测试AUTH_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Get</td>
        <td>测试GET_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Put</td>
        <td>测试PUT_REQUEST</td>
        <td>10</td>
    </tr>
</table>

注意,上述测试点不代表完整的测试点结果,只包含了完整测试的百分之80

其中一些测试点为多Client的测试, 并不计算分数(别卷,没有附加分 QwQ)
