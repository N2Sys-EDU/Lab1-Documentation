# myFTP 协议

> 请从[北大教学网](https://course.pku.edu.cn)获取接受本Lab任务的链接

MyFTP是我们为了方便同学们快速理解POSIX API设计的一个简单的Lab

在这个Lab中你需要完成一个简单的基于Epoll的单线程FTP Server和FTP Client CLI

Server

本文档描述了MyFTP协议的内容

## 实现要求

1. MyFTP的Client支持以下的命令
    1. `open <IP> <port>`: 建立一个到`<IP>:<port>`的连接
    2. `auth <username> <password>`: 向对侧进行身份验证
    3. `ls`: 获取对方当前运行目录下的文件列表，一个样例输出如下:
        ``` cpp
        123.txt
        ```
    4. `get <filename>`: 将Server运行目录中的`<filename>`文件存放到Client运行目录的`<filename>`中
    5. `put <filename>`: 将Client运行目录中的`<filename>`文件存放当Server运行目录的`<filename>`中
    6. `quit`: 如有连接则先断开，后关闭Client
2. MyFTP的Server需要支持如下的功能特点
    1. 权限控制: 用户需要登录这里简化为用户名为`user`密码为`123123`
    2. 获取文件列表: 这里文件列表由指令`ls -r`生成，可以使用`popen`或者`pipe+fork+execv`的手段获取其他进程的输出结果
    3. 下载文件
    4. 上传文件

### Client实现要求

我们在测试的过程中会通过指令`./ftp_server`在`build`目录中启动Client

### Server实现要求

我们会用指令`./ftp_client <IP> <Port>`在`build`目录中启动Server

## 技术规范

### 数据报文格式

``` cpp
struct {
    byte m_protocol[MAGIC_NUMBER_LENGTH]; /* protocol magic number (6 bytes) */
    type m_type;                          /* type (1 byte) */
    status m_status;                      /* status (1 byte) */
    uint32_t m_length;                    /* length (4 bytes) in Big endian*/
} __attribute__ ((packed));
```

每一个数据报文的开头都将以这个报头发送，基于TCP协议进行通信

即每一个802.3网络上的报文都有如下的形式:

`|802.3 Header|IP Header|TCP Header|myFTP Header|myFTP Data|data|`

其中TCP Header以及之前的头会由系统生成, 我们要实现的是一个应用层协议

### 网络请求

对于所有的请求，头中的`m_protocol`字段的值都应当为

``` cpp
const byte MAGIC_NUMBER[MAGIC_NUMBER_LENGTH] = {'\xe3', 'm', 'y', 'f', 't', 'p'};
```

每一种类型的请求和对应的回复的`m_type`为:

``` cpp
const type OPEN_CONN_REQUEST = '\xA1';
const type OPEN_CONN_REPLY = '\xA2';
const type AUTH_REQUEST = '\xA3';
const type AUTH_REPLY = '\xA4';
const type LIST_REQUEST = '\xA5';
const type LIST_REPLY = '\xA6';
const type GET_REQUEST = '\xA7';
const type GET_REPLY = '\xA8';
const type FILE_DATA = '\xFF';
const type PUT_REQUEST = '\xA9';
const type PUT_REPLY = '\xAA';
const type QUIT_REQUEST = '\xAB';
const type QUIT_REPLY = '\xAC';
```

对于请求的`m_status`字段没有特殊作用，对于回复可能存在如下的值:

``` cpp
const status UNUSED = 0;
const status UP = 1;
const status DOWN = 0;
const status SUCCESS = 1;
const status FAIL = 0;
```

具体发生情况会在下面给出

报文的长度`m_length`为**大端法**表示，长度包括包头和数据的**总长度**, 你可以认为在任何时候报文的长度不会超过`limits.h`中定义的`INT_MAX`

### 协议概述

![](1.png)

上图描述了Client的状态机, Server对于每一个Client, 以及Client自身都应当维护这样一个简单的状态机

### `OPEN_CONN_REQUEST`

该指令由Client发出，用于和Server建立一个TCP连接

`m_type = OPEN_CONN_REQUEST`

该请求若成功应接收到一个从server发送的报文

``` cpp
m_type = OPEN_CONN_REPLY
m_status = UP
```

若失败则无服务端回复，这里客户端的行为应当为持续等待或直接退出

### `AUTH_REQUEST`

该指令由Client发出，用户和Server进行身份验证

`m_type = AUTH_REQUEST`

若身份验证成功，则应当收到一个从server发送的报文

``` cpp
m_type = AUTH_REPLY
m_status = SUCCESS
```

对于其他情况，则应当收到一个从server发送的报文

``` cpp
m_type = AUTH_REPLY
m_status = FAIL
```

### `LIST_REQUEST`

该指令由Client发出，用户在已经完成身份验证的情况下可以向Server发送该请求

若没有完成身份验证则服务器不应当做出任何反馈

该指令的头为

``` cpp
m_type = LIST_REPLY
m_status = UNUSED
```

数据为

```
123.txt
```

即将指令`ls`返回的内容直接返回。注意，为了便于我们对你的程序进行判断，在返回内容的结尾应当补充一个`'\0'`符号

### `GET_REQUEST`

该指令由Client发出，用户在已经完成身份验证的情况下可以向Server发送该请求

若没有完成身份验证则服务器不应当做出任何反馈

将Server的文件下载到本地

实现的时候**不需要**考虑存在文件夹的情况（可以认为不存在子文件夹）

发起的请求为

``` cpp
m_type = GET_REQUEST
```

若执行`ls -r`指令失败，则应当返回报文`m_type = GET_REPLY, m_status = FAIL`

若成功则返回的结果包含两个报文

1. `m_type = GET_REPLY, m_status = SUCCESS`，并且不包含任何数据
2. `m_type = FILE_DATA, m_status = UNUSED`，该报文包含文件的二进制数据

### `PUT_REQUEST`

该指令由Client发出，用户在已经完成身份验证的情况下可以向Server发送该请求

若没有完成身份验证则服务器不应当做出任何反馈

将本地的文件上传到Server

实现的时候**不需要**考虑存在文件夹的情况（可以认为不存在子文件夹）

发起的请求为

``` cpp
m_status = PUT_REQUEST
```

数据为该文件名称

收到该请求后，Server应当回复一报文`m_type = PUT_REPLY, m_status = UNUSED`

在收到该回复后，Client可开始发送文件，文件由一个报文组成

该报文头为`m_type = FILE_DATA`，数据为待发送文件的二进制数据

### `QUIT_REQUEST`

该指令由Client发出，用户可以在完成`OPEN_CONN_REQUEST`后发送该请求

Server和Client应当关闭连接

该报文为

``` cpp
m_type = QUIT_REQUEST
```

Server应当回复

``` cpp
m_type = QUIT_REPLY
m_status = UNUSED
```

当收到Server的回复**后**，Client才应当关闭该连接

## 如何进行测试

我们采用了gtest进行测试，CMake会自动从Github克隆仓库，因此请保证至少你的Terminal能够访问Github

如果无法进行正常测试，请和助教联系

在build目录中执行`.\ftp_test`即可进行测试

要求:
1. Server可执行程序和Client可执行程序名称需要严格按照`ftp_server`和`ftp_client`命名 (在下发的模板中我们已经完成了这一段代码)你只需要将对应的源文件添加到CMake中对应的target上即可
2. 具体协议内容请参考技术规范一节实现,在进行某一项测试的时候,只有一侧会使用你的Server/Client,另一侧为标准程序,为了确保能够正常通信,我们希望你的代码能够和标准程序进行交互
3. 任何对提供的**二进制文件**的修改均被视为作弊行为, 一经发现该Lab将被记为0分

## 分数计算

注意这里测试点不代表所有测试点, 这里展示的测试点只占最终该Lab分数的80%, 剩余的测试点会在Deadline后放出

以下的表格给出了每一个测试点对应的ID和内容，你可以通过`.\ftp_test --gtest_filter=ID`来只针对某个测试点执行测试

或者使用通配符如`.\ftp_test --gtest_filter=FTPServer.*`只针对Server进行测试

每一个测试点名由`${类别}.${测试点名称}`构成

<table>
    <tr>
        <td>类别</td>
        <td>测试点名称</td>
        <td>测试内容</td>
        <td>分数占比</td>
    </tr>
    <tr>
        <td rowspan="5">FTPServer</td>
        <td>Open</td>
        <td>测试OPEN_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Auth</td>
        <td>测试AUTH_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Get</td>
        <td>测试GET_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Put</td>
        <td>测试PUT_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>List</td>
        <td>测试LIST_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td rowspan="4">FTPClient</td>
        <td>Open</td>
        <td>测试OPEN_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Auth</td>
        <td>测试AUTH_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Get</td>
        <td>测试GET_REQUEST</td>
        <td>10</td>
    </tr>
    <tr>
        <td>Put</td>
        <td>测试PUT_REQUEST</td>
        <td>10</td>
    </tr>
</table>

注意,上述测试点不代表完整的测试点结果,只包含了完整测试的百分之80
